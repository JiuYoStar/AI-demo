# 1

### flask应用程序架构

-   路由
-   请求响应处理
-   模板
-   应用请求上下文
-   配置
-   蓝图
-   扩展

#### 应用对象

```py
from flask import Flask
app = Flask(__name__)

__name__ >> 在哪里找资源,模板文件静态资源在哪儿找
```

#### 路由

```py
@app.route('/')
def hello_world():
    return '<p>Hello, World!</p>'
```

#### 请求和响应处理

```python
# Flask将传入的HTTP请求和传出的响应封装在便捷的对象中
# 通过request和response对象访问
# 框架自动处理HTTP消息和Python对象之间的转换。

from flask import request

@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username') # 从request中解析
    return f'Hello, {username}!' # 返回response
```

#### 模板

```py
from flask import render_template

@app.route('/hello/<name>')
def hello(name):
    return render_template('hello.html', name=name) # jinja2的模板语法
```

#### 上下文处理

Flask使用上下文对象使某些变量全局可访问，而无需显式传递：

-   **应用上下文**：提供对应用特定数据的访问
-   **请求上下文**：提供对请求特定数据的访问

```py
from flask import Flask, request, g, current_app

app = Flask(__name__)

@app.before_request
def before_request():
    # 在请求开始时设置一些全局变量
    g.user = request.args.get('user', 'Guest')
    print("Before request: g.user =", g.user)

@app.route('/')
def index():
    # 直接访问全局上下文对象 g 和 request
    return f"Hello, {g.user}! You are visiting {request.path}"

@app.teardown_request
def teardown_request(exception):
    # 请求结束时自动清理上下文
    print("Teardown: 清理上下文资源")

if __name__ == '__main__':
    app.run(debug=True)
```

