# Python 装饰器 vs JavaScript 对比

## 什么是装饰器

装饰器是一种设计模式，用于在不修改原函数代码的情况下，给函数添加额外的功能。

| 特性 | Python | JavaScript |
|-----|--------|-----------|
| **语法** | `@decorator` | 无原生装饰器语法（需Babel或装饰器提案） |
| **实现** | 函数返回函数 | 高阶函数 |
| **类装饰器** | ✅ 支持 | 部分支持（提案阶段） |
| **多个装饰器** | ✅ 支持堆叠 | ✅ 支持（手动嵌套） |

## 装饰器实战示例对比

### 1️⃣ 日志/调试装饰器

**Python 实现：**

```python
def log(func):
    def wrapper(*args, **kwargs):
        print(f"调用函数: {func.__name__}, args={args}, kwargs={kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log
def add(x, y):
    return x + y

# 使用
add(3, 5)  # 输出: 调用函数: add, args=(3, 5), kwargs={}
```

**JavaScript 实现：**

```javascript
function log(func) {
    return function(...args) {
        console.log(`调用函数: ${func.name}, args=${JSON.stringify(args)}`);
        return func(...args);
    }
}

// 手动装饰
const add = log(function add(x, y) {
    return x + y;
});

// 使用
add(3, 5);  // 输出: 调用函数: add, args=[3,5]
```

---

### 2️⃣ 性能计时装饰器

**Python 实现：**

```python
import time

def timeit(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 耗时 {end - start:.3f}s")
        return result
    return wrapper

@timeit
def slow_add(x, y):
    time.sleep(1)
    return x + y

# 使用
slow_add(3, 5)  # 输出: slow_add 耗时 1.001s
```

**JavaScript 实现：**

```javascript
function timeit(func) {
    return function(...args) {
        const start = Date.now();
        const result = func(...args);
        const end = Date.now();
        console.log(`${func.name} 耗时 ${(end - start) / 1000}s`);
        return result;
    }
}

// 手动装饰
const slowAdd = timeit(function slowAdd(x, y) {
    // 模拟延迟
    const start = Date.now();
    while (Date.now() - start < 1000) {}
    return x + y;
});

// 使用
slowAdd(3, 5);  // 输出: slowAdd 耗时 1.0s
```

---

### 3️⃣ 权限校验装饰器

**Python 实现：**

```python
def require_admin(func):
    def wrapper(user, *args, **kwargs):
        if user != "admin":
            raise PermissionError("无权限访问")
        else:
            print("权限校验通过")
            return func(user, *args, **kwargs)
    return wrapper

@require_admin
def delete_db(user):
    return "删除数据库操作"

# 使用
try:
    delete_db("guest")  # 抛出异常
except PermissionError as e:
    print("异常:", e)

delete_db("admin")  # 输出: 权限校验通过
```

**JavaScript 实现：**

```javascript
function requireAdmin(func) {
    return function(user, ...args) {
        if (user !== "admin") {
            throw new Error("无权限访问");
        } else {
            console.log("权限校验通过");
            return func(user, ...args);
        }
    }
}

// 手动装饰
const deleteDb = requireAdmin(function deleteDb(user) {
    return "删除数据库操作";
});

// 使用
try {
    deleteDb("guest");  // 抛出异常
} catch (e) {
    console.log("异常:", e.message);
}

deleteDb("admin");  // 输出: 权限校验通过
```

---

### 4️⃣ 缓存装饰器（性能优化）

**Python 实现：**

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

# 使用
print(fib(35))  # 快速计算
print(fib.cache_info())  # 查看缓存信息
```

**JavaScript 实现：**

```javascript
function memoize(func) {
    const cache = new Map();
    return function(...args) {
        const key = JSON.stringify(args);
        if (cache.has(key)) {
            return cache.get(key);
        }
        const result = func(...args);
        cache.set(key, result);
        return result;
    }
}

// 手动装饰
const fib = memoize(function fib(n) {
    if (n < 2) return n;
    return fib(n - 1) + fib(n - 2);
});

// 使用
console.log(fib(35));  // 快速计算
```

---

### 5️⃣ Web 框架路由装饰器

**Python 实现（Flask 风格）：**

```python
ROUTES = {}

def route(path):
    def decorator(func):
        ROUTES[path] = func
        return func
    return decorator

@route("/")
def home():
    return {"msg": "hello"}

@route("/about")
def about():
    return {"msg": "about page"}

# 使用
print(ROUTES["/"]())       # {'msg': 'hello'}
print(ROUTES["/about"]())  # {'msg': 'about page'}
```

**JavaScript 实现（Express 风格）：**

```javascript
const ROUTES = {};

function route(path) {
    return function(func) {
        ROUTES[path] = func;
        return func;
    }
}

// 手动装饰
const home = route("/")(function home() {
    return { msg: "hello" };
});

const about = route("/about")(function about() {
    return { msg: "about page" };
});

// 使用
console.log(ROUTES["/"]());       // { msg: "hello" }
console.log(ROUTES["/about"]());  // { msg: "about page" }
```

---

## 装饰器对比总结

| 功能 | Python | JavaScript |
|-----|--------|-----------|
| **基本语法** | `@decorator` | 手动调用高阶函数 |
| **带参数装饰器** | `@decorator(args)` | `decorator(args)(func)` |
| **多装饰器堆叠** | `@d1` `@d2` `def f():` | `d1(d2(func))` |
| **保留函数信息** | `@functools.wraps` | 手动复制属性 |
| **类装饰器** | `@decorator` `class C:` | 提案阶段 |
| **方法装饰器** | `@property`, `@staticmethod` | `get/set`, `static` |
| **内置装饰器** | `@lru_cache`, `@dataclass` | 需第三方库 |

## 常见装饰器模式

### 带参数的装饰器

**Python：**

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Ada")  # 打印3次
```

**JavaScript：**

```javascript
function repeat(times) {
    return function(func) {
        return function(...args) {
            let result;
            for (let i = 0; i < times; i++) {
                result = func(...args);
            }
            return result;
        }
    }
}

const greet = repeat(3)(function greet(name) {
    console.log(`Hello, ${name}!`);
});

greet("Ada");  // 打印3次
```

### 类装饰器

**Python：**

```python
def singleton(cls):
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class Database:
    def __init__(self):
        self.connection = "connected"

db1 = Database()
db2 = Database()
print(db1 is db2)  # True
```

**JavaScript：**

```javascript
function singleton(cls) {
    let instance;
    return function(...args) {
        if (!instance) {
            instance = new cls(...args);
        }
        return instance;
    }
}

const Database = singleton(class Database {
    constructor() {
        this.connection = "connected";
    }
});

const db1 = new Database();
const db2 = new Database();
console.log(db1 === db2);  // True
```

## 完整测试代码

**Python 完整示例：**

```python
import time
from functools import lru_cache

# 装饰器定义（见上文）

if __name__ == "__main__":
    print("==== 1. 日志/调试 ====")
    print(add(3, 5))

    print("\n==== 2. 性能计时 ====")
    print(slow_add(3, 5))

    print("\n==== 3. 权限校验 ====")
    try:
        print(delete_db("guest"))
    except PermissionError as e:
        print("异常:", e)
    print(delete_db("admin"))

    print("\n==== 4. 缓存 ====")
    print(f"fib(35) = {fib(35)}")
    print(f"fib(6) = {fib(6)}")
    print("fib.cache_info():", fib.cache_info())

    print("\n==== 5. 模拟 Web 框架路由 ====")
    print("访问 / =>", ROUTES["/"]())
    print("访问 /about =>", ROUTES["/about"]())
```

## 总结

- **Python** 的装饰器是语言原生特性，语法简洁优雅（`@`语法糖）
- **JavaScript** 需要手动调用高阶函数，或使用处于提案阶段的装饰器语法
- 两者核心思想相同：都是通过函数包装函数来增强功能
- Python 有更丰富的内置装饰器（`@property`, `@staticmethod`, `@lru_cache`等）
- JavaScript 需要依赖第三方库或自己实现

装饰器是函数式编程的重要工具，在日志、性能监控、权限控制、缓存等场景广泛应用。
