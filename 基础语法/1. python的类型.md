# 类型差异速查

## 1. 基础类型差异
| 分类 | Python | JS 开发者注意事项 |
| :--- | :--- | :--- |
| **数值** | `int`, `float` | **区分整型和浮点数**。JS 只有 `Number`。 |
| **布尔** | `True`, `False` | **首字母大写**，不要写错成 `true/false`。 |
| **空值** | `None` | 对应 `null`。Python **没有 `undefined`**。 |

## 2. 集合与序列 (容器)
| 类型 | Python | JS 对应 / 差异点 |
| :--- | :--- | :--- |
| **列表** | `list` | 语法：`[1, 2]`。对应 JS 的 `Array`。 |
| **元组** | `tuple` | 语法：`(1, 2)`。**不可变**数组，创建后不能修改元素。 |
| **字典** | `dict` | 语法：`{'a': 1}`。对应 JS 的 `Map` 或 `Object`。键必须是不可变类型。 |
| **集合** | `set` | 语法：`{1, 2}`。对应 JS 的 `Set`。 |
| **范围** | `range` | 语法：`range(10)`。惰性生成器，类似 JS 手写的 `[...Array(10).keys()]` 但内存占用极低。 |

## 3. 函数
*   **定义方式**: 使用 `def func_name(args):`。
*   **匿名函数**: `lambda x: x + 1`，功能也叫“拉姆达表达式”。**注意：** 只能写单行表达式，不能包含 `return`、`if` (除了三元) 等复杂逻辑，远弱于 JS 的箭头函数。

## 4. 关键原则
1.  **不可变性 (Immutability)**：
    *   Python 的内置类型中，`int`, `float`, `str`, `tuple`, `bool` 都是**绝对不可变**的。
    *   JS 的 `String` 也是不可变的，但 Python 的 `tuple` 提供了不可变数组的场景。
2.  **真值与假值 (Falsy)**：
    *   Python 的假值：`None`, `False`, `0`, `0.0`, `""`, `[]`, `{}`, `()`, `set()`。
    *   **不同点**：JS 中 `[]` 和 `{}` 是 `true`，而 **Python 中空容器均为 `False`**。

## 5. 类型判断 (Type Checking)

| 功能 | Python | JS 对应 | 说明 |
| :--- | :--- | :--- | :--- |
| **获取类型** | `type(obj)` | `typeof obj` | 返回类型对象，如 `<class 'int'>` |
| **精确判断** | `type(obj) is int` | `typeof obj === 'number'` | 严格对比类型 |
| **继承判断** | `isinstance(obj, list)` | `obj instanceof Array` | **推荐**，支持子类判断 |

---

## 惰性生成器

**核心思想** 不到万不得已,不去执行,类似yield

- `range()`：最经典的惰性序列，无论范围多大，占用的内存几乎恒定。
- `map(func, iterable)`：只有在迭代时才会对元素执行 `func`。
- `filter(func, iterable)`：迭代时才判断元素是否符合过滤条件。
- `zip(*iterables)`：并行迭代多个可迭代对象，按需产生元组。
- `enumerate(iterable)`：按需生成索引和值的元组。
- `reversed(seq)`：返回一个反向迭代器，而不改变原序列。

